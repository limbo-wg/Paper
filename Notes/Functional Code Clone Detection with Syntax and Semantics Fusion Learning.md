## Functional Code Clone Detection with Syntax and Semantics Fusion Learning

**提出了一种联合代码表示形式，用混合嵌入技术来学习代码中隐藏的语法和语义特征，并介绍了一种用于功能性代码克隆检测的新粒度，使用有监督深度学习模型检测功能性代码克隆**

#### 背景介绍

在软工领域中，代码克隆检测是一项基本任务，包括重构、代码检索、代码复用和错误检测等

代码克隆的四种分类（依据代码相似程度）：

1. 除空格、注释外都相同
2. 除变量名、类型、函数名等外都相同
3. 存在某些语句的添加或删除
4. 代码功能相同但结构和语法不同

代码克隆检测主要有三个步骤：

1. 代码预处理：去除代码中不相关的内容，比如注释
2. 代码表示：提取代码中不同的抽象形式，比如AST和PDG（不能直接用于神经网络）
3. 代码相似度比较：检测不同代码之间的距离，当距离达到阈值时检测完成

**两种代码表示方法的比较：**

| AST (Abstract Syntax Tree)   | PDG (Program Dependence Graph) |
| ---------------------------- | ------------------------------ |
| 基于语法(syntax-based)       | 基于语义(semantic-based)       |
| 粒度较细                     | 粒度较粗                       |
| 每个运算符或变量都是一个节点 | 每个代码块是一个节点           |
| 不能捕获关于代码块的信息     | 复杂代码的PDG会很复杂          |
| 用于表示方法                 | 用于表示整个文件               |

#### 主要贡献

* 提出一种细粒度的代码函数识别方法
* 提出一种使用嵌入学习语法语义特征的联合代码表示形式
* 展示了提出的方法在C++程序上的实现

方法的主要步骤：

1. 通过调用图确定代码功能：将有调用关系的方法的功能组合在一起，没有调用关系的方法作为独立功能
2. 提取语法和语义特征：通过AST和CFG提取语法和语义特征，以提取代码特征
3. 训练DNN模型：将功能性克隆检测转换为二分类问题，当遇到两个新功能时，提取并融合特征向量，并使用DNN模型预测是否为代码克隆





